# ProjectAssistant详细设计文档

## 1. 项目概述

ProjectAssistant是一个为单个用户设计的本地多功能工具应用，主要包含以下核心功能模块：

- **项目管理**：管理项目周期、计算工作日、提供可视化日历展示
- **金额转换**：数字金额与中文大写金额互转
- **文档生成**：基于模板生成Word和Excel文档
- **文本纠错**：提供中文文本纠错与替换服务

此应用使用Java与JavaFX开发，使用H2作为嵌入式数据库，采用本地文件存储。应用设计为单用户使用，无需网络连接，所有数据存储在本地。

## 2. 代码逻辑详细分析

### 2.1 核心启动流程

从`package.bat`脚本分析，应用启动流程如下：

```
1. 初始化环境变量(Java、Maven路径)
2. 创建应用目录结构(数据目录、配置目录、库文件目录等)
3. 复制必要的依赖文件(JavaFX库、H2数据库等)
4. 创建启动脚本(普通启动与调试启动)
5. Java程序启动入口为JAR文件：multi-tools-1.0.jar
```

启动脚本中的核心Java命令：

```bat
java -Dfile.encoding=UTF-8 -Dh2.bindAddress=127.0.0.1 --class-path="multi-tools-1.0.jar;service_data\lib\*;resources" --module-path="service_data\lib\javafx-modules" --add-modules=javafx.controls,javafx.fxml,javafx.graphics -jar "multi-tools-1.0.jar"
```

此命令确保：
1. 使用UTF-8编码
2. H2数据库仅绑定本地地址
3. 加载必要的JavaFX模块
4. 设置正确的类路径包含所有依赖

### 2.2 项目管理模块

#### 2.2.1 Project类分析

`Project.java`是项目管理模块的核心数据模型：

```java
public class Project {
    private Integer id;              // 项目唯一标识符
    private String name;             // 项目名称
    private Integer reviewPeriod;    // 审核周期(天)
    private LocalDate onlineDate;    // 上线日期
    private Integer registrationPeriod; // 报名周期(天)
    private LocalDate registrationEndDate; // 报名截止日期
    private LocalDate earliestReviewDate;  // 最早审核日期
    private Integer expectedReviewTime;    // 预计审核时间(天)
    private Integer expertReviewTime;      // 专家评审时间
    private String remark;                 // 备注信息
}
```

项目状态计算逻辑：

```java
// 计算项目状态
public String getStatus() {
    LocalDate today = LocalDate.now();
    
    // 已结束：今天已超过预计审核结束日期
    if (getExpectedReviewEndDate() != null && today.isAfter(getExpectedReviewEndDate())) {
        return "已结束";
    }
    
    // 审核中：今天在报名截止日期之后且不晚于预计审核结束日期
    if (registrationEndDate != null && today.isAfter(registrationEndDate) && 
        (getExpectedReviewEndDate() == null || !today.isAfter(getExpectedReviewEndDate()))) {
        return "审核中";
    }
    
    // 报名中：今天不晚于报名截止日期
    if (registrationEndDate == null || !today.isAfter(registrationEndDate)) {
        return "报名中";
    }
    
    return "未知";
}
```

工作日期计算逻辑：

```java
// 计算预计审核结束日期
public LocalDate getExpectedReviewEndDate() {
    if (earliestReviewDate == null || expectedReviewTime == null) {
        return null;
    }
    return addWorkingDays(earliestReviewDate, expectedReviewTime);
}

// 添加工作日
private LocalDate addWorkingDays(LocalDate date, int days) {
    LocalDate result = date;
    int addedDays = 0;
    
    while (addedDays < days) {
        result = result.plusDays(1);
        if (isWorkingDay(result)) {
            addedDays++;
        }
    }
    
    return result;
}

// 判断是否为工作日(非周末且非节假日)
private boolean isWorkingDay(LocalDate date) {
    DayOfWeek dayOfWeek = date.getDayOfWeek();
    return !(dayOfWeek == DayOfWeek.SATURDAY || dayOfWeek == DayOfWeek.SUNDAY ||
             isHoliday(date)); // 需实现isHoliday方法判断法定节假日
}
```

#### 2.2.2 项目服务层

`ProjectService.java`负责项目数据的CRUD操作：

```java
public class ProjectService {
    private final ProjectDAO projectDAO;  // 数据访问对象
    private final HolidayService holidayService; // 节假日服务
    
    // 保存项目，自动计算各关键日期
    public void saveProject(Project project) {
        // 计算报名截止日期
        if (project.getOnlineDate() != null && project.getRegistrationPeriod() != null) {
            project.setRegistrationEndDate(
                addWorkingDays(project.getOnlineDate(), project.getRegistrationPeriod())
            );
        }
        
        // 计算最早审核日期(报名截止日期后的第一个工作日)
        if (project.getRegistrationEndDate() != null) {
            LocalDate nextDay = project.getRegistrationEndDate().plusDays(1);
            while (!isWorkingDay(nextDay)) {
                nextDay = nextDay.plusDays(1);
            }
            project.setEarliestReviewDate(nextDay);
        }
        
        projectDAO.save(project);
    }
    
    // 其他CRUD方法：findAll, findById, deleteById等
}
```

#### 2.2.3 日历视图控制器

`ProjectCalendarController.java`负责项目日历可视化：

```java
public class ProjectCalendarController {
    @FXML private CalendarView calendarView;
    @FXML private ListView<Project> projectListView;
    private ProjectService projectService;
    
    @FXML
    public void initialize() {
        // 初始化日历视图
        configureCalendarView();
        
        // 加载项目列表
        loadProjects();
        
        // 设置项目列表选择监听
        projectListView.getSelectionModel().selectedItemProperty().addListener(
            (obs, oldSelection, newSelection) -> {
                if (newSelection != null) {
                    highlightProjectDates(newSelection);
                }
            }
        );
    }
    
    // 配置日历视图
    private void configureCalendarView() {
        // 设置日历单元格工厂，显示每天的项目状态
        calendarView.setDayCellFactory(param -> new DateCell() {
            @Override
            public void updateItem(LocalDate date, boolean empty) {
                super.updateItem(date, empty);
                
                if (!empty) {
                    List<Project> projectsForDate = getProjectsForDate(date);
                    if (!projectsForDate.isEmpty()) {
                        // 设置日期单元格样式和提示信息
                        setStyle("-fx-background-color: lightblue;");
                        setTooltip(createTooltipForProjects(projectsForDate));
                    }
                    
                    // 标记节假日
                    if (holidayService.isHoliday(date)) {
                        setStyle("-fx-background-color: pink;");
                    }
                    
                    // 标记周末
                    DayOfWeek dayOfWeek = date.getDayOfWeek();
                    if (dayOfWeek == DayOfWeek.SATURDAY || dayOfWeek == DayOfWeek.SUNDAY) {
                        setStyle("-fx-background-color: lightgray;");
                    }
                }
            }
        });
    }
    
    // 在日历中高亮显示项目相关日期
    private void highlightProjectDates(Project project) {
        calendarView.clearMarkedDates();
        
        // 高亮上线日期
        if (project.getOnlineDate() != null) {
            calendarView.markDate(project.getOnlineDate(), "-fx-background-color: green;");
        }
        
        // 高亮报名截止日期
        if (project.getRegistrationEndDate() != null) {
            calendarView.markDate(project.getRegistrationEndDate(), "-fx-background-color: orange;");
        }
        
        // 高亮审核期间
        if (project.getEarliestReviewDate() != null && project.getExpectedReviewEndDate() != null) {
            LocalDate current = project.getEarliestReviewDate();
            while (!current.isAfter(project.getExpectedReviewEndDate())) {
                if (isWorkingDay(current)) {
                    calendarView.markDate(current, "-fx-background-color: yellow;");
                }
                current = current.plusDays(1);
            }
        }
    }
    
    // 项目操作方法：添加、编辑、删除等
    @FXML
    private void handleAddProject() {
        // 打开项目编辑对话框
        Project newProject = new Project();
        boolean confirmed = showProjectDialog("添加项目", newProject);
        
        if (confirmed) {
            projectService.saveProject(newProject);
            loadProjects(); // 重新加载项目列表
        }
    }
    
    // 其他UI事件处理方法
}
```

### 2.3 金额转换模块

#### 2.3.1 金额转换核心算法

`AmountConverter.java`包含数字与中文大写金额的互相转换逻辑：

```java
public class AmountConverter {
    // 数字字符数组
    private static final char[] DIGIT_CHAR = {'零', '壹', '贰', '叁', '肆', '伍', '陆', '柒', '捌', '玖'};
    // 单位字符数组
    private static final char[] UNIT_CHAR = {'分', '角', '元', '拾', '佰', '仟', '万', '拾', '佰', '仟', '亿', '拾', '佰', '仟'};
    // 特殊数值处理
    private static final String[] SPECIAL_VALUES = {"整", "零元整", "零元零角整"};
    
    // 数字金额转中文大写
    public String convertToChineseUpper(double amount) {
        // 处理特殊情况
        if (amount == 0) {
            return "零元整";
        }
        
        if (amount < 0) {
            return "负" + convertToChineseUpper(-amount);
        }
        
        // 将金额转为以分为单位的长整型
        long amountInCents = Math.round(amount * 100);
        
        // 分解金额为整数部分和小数部分
        long integerPart = amountInCents / 100;
        int decimalPart = (int) (amountInCents % 100);
        
        StringBuilder result = new StringBuilder();
        
        // 处理整数部分
        if (integerPart > 0) {
            processIntegerPart(integerPart, result);
            result.append("元");
        }
        
        // 处理小数部分
        if (decimalPart > 0) {
            processDecimalPart(decimalPart, result);
        } else {
            result.append("整");
        }
        
        // 处理特殊情况和格式调整
        String chineseAmount = result.toString();
        // 替换连续的零
        chineseAmount = chineseAmount.replaceAll("零零+", "零");
        // 去掉元前面的零
        chineseAmount = chineseAmount.replaceAll("零元", "元");
        
        return chineseAmount;
    }
    
    // 处理整数部分
    private void processIntegerPart(long integerPart, StringBuilder result) {
        // 分解每一位数字并转换
        String intStr = String.valueOf(integerPart);
        int length = intStr.length();
        
        for (int i = 0; i < length; i++) {
            int digit = intStr.charAt(i) - '0';
            int unitIndex = length - i + 1; // 对应的单位索引
            
            if (digit != 0) {
                result.append(DIGIT_CHAR[digit]).append(UNIT_CHAR[unitIndex]);
            } else {
                // 处理零的特殊情况
                if (i < length - 1 && intStr.charAt(i + 1) != '0') {
                    result.append('零');
                }
            }
            
            // 处理万、亿等特殊单位
            if (unitIndex == 5 || unitIndex == 9) {
                result.append('万');
            } else if (unitIndex == 13) {
                result.append('亿');
            }
        }
    }
    
    // 处理小数部分
    private void processDecimalPart(int decimalPart, StringBuilder result) {
        int jiao = decimalPart / 10;
        int fen = decimalPart % 10;
        
        if (jiao > 0) {
            result.append(DIGIT_CHAR[jiao]).append('角');
        }
        
        if (fen > 0) {
            result.append(DIGIT_CHAR[fen]).append('分');
        }
    }
    
    // 中文大写转数字金额
    public double convertToNumber(String chineseAmount) {
        // 特殊情况处理
        if (chineseAmount == null || chineseAmount.trim().isEmpty()) {
            return 0;
        }
        
        // 去除可能存在的"人民币"字样
        chineseAmount = chineseAmount.replaceAll("人民币", "");
        
        // 负数处理
        boolean isNegative = false;
        if (chineseAmount.startsWith("负") || chineseAmount.startsWith("负")) {
            isNegative = true;
            chineseAmount = chineseAmount.substring(1);
        }
        
        // 解析数字和单位
        double result = parseChineseAmount(chineseAmount);
        
        return isNegative ? -result : result;
    }
    
    // 解析中文金额字符串
    private double parseChineseAmount(String chineseAmount) {
        double result = 0;
        
        // 处理整数部分和小数部分
        int yuanIndex = chineseAmount.indexOf('元');
        
        // 有"元"字的情况
        if (yuanIndex != -1) {
            // 处理整数部分
            String integerPart = chineseAmount.substring(0, yuanIndex);
            result = parseChineseInteger(integerPart);
            
            // 处理小数部分
            if (yuanIndex < chineseAmount.length() - 1) {
                String decimalPart = chineseAmount.substring(yuanIndex + 1);
                // 排除"整"字
                if (!decimalPart.equals("整")) {
                    result += parseChineseDecimal(decimalPart);
                }
            }
        } else {
            // 没有"元"字的情况，可能只有小数部分
            if (chineseAmount.contains("角") || chineseAmount.contains("分")) {
                result = parseChineseDecimal(chineseAmount);
            } else {
                // 尝试解析为整数
                result = parseChineseInteger(chineseAmount);
            }
        }
        
        return result;
    }
    
    // 解析中文整数部分
    private double parseChineseInteger(String chineseInteger) {
        // 复杂的中文数字解析逻辑，处理亿、万等单位
        // ...此处省略具体实现...
    }
    
    // 解析中文小数部分
    private double parseChineseDecimal(String chineseDecimal) {
        double result = 0;
        
        // 处理角
        int jiaoIndex = chineseDecimal.indexOf('角');
        if (jiaoIndex != -1) {
            char jiaoCh = chineseDecimal.charAt(jiaoIndex - 1);
            int jiaoValue = getChineseDigitValue(jiaoCh);
            result += jiaoValue * 0.1;
        }
        
        // 处理分
        int fenIndex = chineseDecimal.indexOf('分');
        if (fenIndex != -1) {
            char fenCh = chineseDecimal.charAt(fenIndex - 1);
            int fenValue = getChineseDigitValue(fenCh);
            result += fenValue * 0.01;
        }
        
        return result;
    }
    
    // 获取中文数字对应的数值
    private int getChineseDigitValue(char ch) {
        for (int i = 0; i < DIGIT_CHAR.length; i++) {
            if (DIGIT_CHAR[i] == ch) {
                return i;
            }
        }
        return 0;
    }
}
```

#### 2.3.2 金额转换控制器

`AmountConverterController.java`处理用户界面交互：

```java
public class AmountConverterController {
    @FXML private TextField numberInput;
    @FXML private TextField chineseInput;
    @FXML private Button convertToChineseButton;
    @FXML private Button convertToNumberButton;
    @FXML private ListView<String> historyListView;
    
    private AmountConverter converter = new AmountConverter();
    private ObservableList<String> conversionHistory = FXCollections.observableArrayList();
    
    @FXML
    public void initialize() {
        // 绑定历史记录列表
        historyListView.setItems(conversionHistory);
        
        // 添加输入验证
        numberInput.textProperty().addListener((obs, oldText, newText) -> {
            validateNumberInput(newText);
        });
        
        // 加载保存的历史记录
        loadConversionHistory();
    }
    
    // 数字转中文按钮事件
    @FXML
    private void handleConvertToChinese() {
        try {
            String numberText = numberInput.getText().trim();
            if (numberText.isEmpty()) {
                showAlert("请输入数字金额");
                return;
            }
            
            double amount = Double.parseDouble(numberText);
            String chineseAmount = converter.convertToChineseUpper(amount);
            
            chineseInput.setText(chineseAmount);
            
            // 记录转换历史
            addToHistory(String.format("数字转中文: %s → %s", numberText, chineseAmount));
        } catch (NumberFormatException e) {
            showAlert("请输入有效的数字金额");
        } catch (Exception e) {
            showAlert("转换出错: " + e.getMessage());
        }
    }
    
    // 中文转数字按钮事件
    @FXML
    private void handleConvertToNumber() {
        try {
            String chineseText = chineseInput.getText().trim();
            if (chineseText.isEmpty()) {
                showAlert("请输入中文金额");
                return;
            }
            
            double amount = converter.convertToNumber(chineseText);
            
            // 格式化数字，保留两位小数
            String formattedAmount = String.format("%.2f", amount);
            numberInput.setText(formattedAmount);
            
            // 记录转换历史
            addToHistory(String.format("中文转数字: %s → %s", chineseText, formattedAmount));
        } catch (Exception e) {
            showAlert("转换出错: " + e.getMessage());
        }
    }
    
    // 验证数字输入
    private void validateNumberInput(String input) {
        if (input.isEmpty()) {
            convertToChineseButton.setDisable(false);
            return;
        }
        
        try {
            // 允许输入数字、小数点和负号
            if (input.matches("-?\\d*\\.?\\d*")) {
                double value = Double.parseDouble(input);
                // 限制金额范围
                if (value >= -999999999.99 && value <= 999999999.99) {
                    convertToChineseButton.setDisable(false);
                } else {
                    convertToChineseButton.setDisable(true);
                }
            } else {
                convertToChineseButton.setDisable(true);
            }
        } catch (NumberFormatException e) {
            convertToChineseButton.setDisable(true);
        }
    }
    
    // 添加到历史记录
    private void addToHistory(String entry) {
        conversionHistory.add(0, entry); // 添加到顶部
        
        // 限制历史记录数量
        if (conversionHistory.size() > 20) {
            conversionHistory.remove(conversionHistory.size() - 1);
        }
        
        // 保存历史记录
        saveConversionHistory();
    }
    
    // 加载历史记录
    private void loadConversionHistory() {
        try {
            Path historyFile = Paths.get("data", "conversion_history.txt");
            if (Files.exists(historyFile)) {
                List<String> history = Files.readAllLines(historyFile);
                conversionHistory.setAll(history);
            }
        } catch (IOException e) {
            // 首次使用可能没有历史记录文件，忽略异常
        }
    }
    
    // 保存历史记录
    private void saveConversionHistory() {
        try {
            Path dataDir = Paths.get("data");
            if (!Files.exists(dataDir)) {
                Files.createDirectories(dataDir);
            }
            
            Path historyFile = dataDir.resolve("conversion_history.txt");
            Files.write(historyFile, conversionHistory);
        } catch (IOException e) {
            showAlert("保存历史记录失败: " + e.getMessage());
        }
    }
    
    // 显示警告对话框
    private void showAlert(String message) {
        Alert alert = new Alert(Alert.AlertType.WARNING);
        alert.setTitle("警告");
        alert.setHeaderText(null);
        alert.setContentText(message);
        alert.showAndWait();
    }
}
```

### 2.4 文档生成模块

#### 2.4.1 文档生成核心算法

`DocumentGenerator.java`负责基于模板生成Word和Excel文档：

```java
public class DocumentGenerator {
    // 模板文件路径
    private static final String TEMPLATE_PATH = "templates/";
    
    // 生成Word文档
    public void generateWordDocument(String templateName, Map<String, Object> data) throws IOException {
        // 加载Word模板文件
        String templatePath = TEMPLATE_PATH + "word/" + templateName + ".docx";
        try (FileInputStream fis = new FileInputStream(templatePath)) {
            XWPFDocument template = new XWPFDocument(fis);
            
            // 遍历模板中的段落，替换占位符
            for (XWPFParagraph paragraph : template.getParagraphs()) {
                replacePlaceholdersInParagraph(paragraph, data);
            }
            
            // 遍历模板中的表格，替换占位符
            for (XWPFTable table : template.getTables()) {
                for (XWPFTableRow row : table.getRows()) {
                    for (XWPFTableCell cell : row.getTableCells()) {
                        for (XWPFParagraph paragraph : cell.getParagraphs()) {
                            replacePlaceholdersInParagraph(paragraph, data);
                        }
                    }
                }
            }
            
            // 保存生成的文档
            String outputPath = "document_output/" + templateName + "_" + 
                                LocalDateTime.now().format(DateTimeFormatter.ofPattern("yyyyMMdd_HHmmss")) + ".docx";
            try (FileOutputStream fos = new FileOutputStream(outputPath)) {
                template.write(fos);
            }
        }
    }
    
    // 生成Excel文档
    public void generateExcelDocument(String templateName, Map<String, Object> data) throws IOException {
        // 加载Excel模板文件
        String templatePath = TEMPLATE_PATH + "excel/" + templateName + ".xlsx";
        try (FileInputStream fis = new FileInputStream(templatePath)) {
            Workbook workbook = new XSSFWorkbook(fis);
            
            // 遍历所有工作表
            for (int i = 0; i < workbook.getNumberOfSheets(); i++) {
                Sheet sheet = workbook.getSheetAt(i);
                
                // 遍历工作表中的所有行
                for (Row row : sheet) {
                    // 遍历行中的所有单元格
                    for (Cell cell : row) {
                        if (cell.getCellType() == CellType.STRING) {
                            String cellValue = cell.getStringCellValue();
                            // 检查单元格是否包含占位符
                            if (cellValue.contains("${")) {
                                String newValue = replacePlaceholders(cellValue, data);
                                cell.setCellValue(newValue);
                            }
                        }
                    }
                }
            }
            
            // 保存生成的文档
            String outputPath = "document_output/" + templateName + "_" + 
                               LocalDateTime.now().format(DateTimeFormatter.ofPattern("yyyyMMdd_HHmmss")) + ".xlsx";
            try (FileOutputStream fos = new FileOutputStream(outputPath)) {
                workbook.write(fos);
            }
        }
    }
    
    // 替换段落中的占位符
    private void replacePlaceholdersInParagraph(XWPFParagraph paragraph, Map<String, Object> data) {
        String text = paragraph.getText();
        
        // 查找可能的占位符
        Matcher matcher = Pattern.compile("\\$\\{([^}]+)\\}").matcher(text);
        
        while (matcher.find()) {
            String placeholder = matcher.group(0); // 完整的占位符，如${客户.姓名}
            String key = matcher.group(1); // 占位符的键，如客户.姓名
            
            // 获取数据
            Object value = getNestedValue(data, key);
            String replacement = value != null ? value.toString() : "";
            
            // 替换文本
            for (XWPFRun run : paragraph.getRuns()) {
                String runText = run.getText(0);
                if (runText != null && runText.contains(placeholder)) {
                    runText = runText.replace(placeholder, replacement);
                    run.setText(runText, 0);
                }
            }
        }
    }
    
    // 替换普通文本中的占位符
    private String replacePlaceholders(String text, Map<String, Object> data) {
        Matcher matcher = Pattern.compile("\\$\\{([^}]+)\\}").matcher(text);
        StringBuffer result = new StringBuffer();
        
        while (matcher.find()) {
            String key = matcher.group(1);
            Object value = getNestedValue(data, key);
            String replacement = value != null ? value.toString() : "";
            matcher.appendReplacement(result, Matcher.quoteReplacement(replacement));
        }
        
        matcher.appendTail(result);
        return result.toString();
    }
    
    // 获取嵌套数据的值，如"客户.姓名"
    private Object getNestedValue(Map<String, Object> data, String key) {
        String[] parts = key.split("\\.");
        
        Object current = data;
        for (String part : parts) {
            if (current instanceof Map) {
                current = ((Map<?, ?>) current).get(part);
            } else {
                return null;
            }
        }
        
        return current;
    }
}
```

#### 2.4.2 模板管理逻辑

`TemplateManager.java`负责模板的管理：

```java
public class TemplateManager {
    private static final String TEMPLATE_DIR = "templates";
    private static final List<String> SUPPORTED_WORD_EXTENSIONS = Arrays.asList(".docx", ".doc");
    private static final List<String> SUPPORTED_EXCEL_EXTENSIONS = Arrays.asList(".xlsx", ".xls");
    
    // 获取所有可用的Word模板
    public List<TemplateInfo> getWordTemplates() {
        return getTemplates(TEMPLATE_DIR + "/word", SUPPORTED_WORD_EXTENSIONS);
    }
    
    // 获取所有可用的Excel模板
    public List<TemplateInfo> getExcelTemplates() {
        return getTemplates(TEMPLATE_DIR + "/excel", SUPPORTED_EXCEL_EXTENSIONS);
    }
    
    // 获取指定目录下的所有模板
    private List<TemplateInfo> getTemplates(String directoryPath, List<String> supportedExtensions) {
        List<TemplateInfo> templates = new ArrayList<>();
        File directory = new File(directoryPath);
        
        if (!directory.exists() || !directory.isDirectory()) {
            return templates;
        }
        
        // 获取目录下的所有文件
        File[] files = directory.listFiles();
        if (files == null) {
            return templates;
        }
        
        // 过滤支持的模板文件
        for (File file : files) {
            if (file.isFile()) {
                String fileName = file.getName();
                String extension = getFileExtension(fileName);
                
                if (supportedExtensions.contains(extension.toLowerCase())) {
                    TemplateInfo templateInfo = new TemplateInfo();
                    templateInfo.setName(getFileNameWithoutExtension(fileName));
                    templateInfo.setPath(file.getAbsolutePath());
                    templateInfo.setLastModified(file.lastModified());
                    templateInfo.setSize(file.length());
                    
                    // 解析模板中的字段
                    templateInfo.setFields(extractTemplateFields(file));
                    
                    templates.add(templateInfo);
                }
            }
        }
        
        return templates;
    }
    
    // 提取模板中的字段（占位符）
    private List<String> extractTemplateFields(File templateFile) {
        Set<String> fields = new HashSet<>();
        String extension = getFileExtension(templateFile.getName()).toLowerCase();
        
        try {
            if (SUPPORTED_WORD_EXTENSIONS.contains(extension)) {
                extractFieldsFromWordTemplate(templateFile, fields);
            } else if (SUPPORTED_EXCEL_EXTENSIONS.contains(extension)) {
                extractFieldsFromExcelTemplate(templateFile, fields);
            }
        } catch (IOException e) {
            // 处理异常，记录日志
        }
        
        return new ArrayList<>(fields);
    }
    
    // 从Word模板中提取字段
    private void extractFieldsFromWordTemplate(File templateFile, Set<String> fields) throws IOException {
        try (FileInputStream fis = new FileInputStream(templateFile)) {
            XWPFDocument document = new XWPFDocument(fis);
            Pattern pattern = Pattern.compile("\\$\\{([^}]+)\\}");
            
            // 提取段落中的字段
            for (XWPFParagraph paragraph : document.getParagraphs()) {
                Matcher matcher = pattern.matcher(paragraph.getText());
                while (matcher.find()) {
                    fields.add(matcher.group(1));
                }
            }
            
            // 提取表格中的字段
            for (XWPFTable table : document.getTables()) {
                for (XWPFTableRow row : table.getRows()) {
                    for (XWPFTableCell cell : row.getTableCells()) {
                        for (XWPFParagraph paragraph : cell.getParagraphs()) {
                            Matcher matcher = pattern.matcher(paragraph.getText());
                            while (matcher.find()) {
                                fields.add(matcher.group(1));
                            }
                        }
                    }
                }
            }
        }
    }
    
    // 从Excel模板中提取字段
    private void extractFieldsFromExcelTemplate(File templateFile, Set<String> fields) throws IOException {
        try (FileInputStream fis = new FileInputStream(templateFile)) {
            Workbook workbook = new XSSFWorkbook(fis);
            Pattern pattern = Pattern.compile("\\$\\{([^}]+)\\}");
            
            // 遍历所有工作表
            for (int i = 0; i < workbook.getNumberOfSheets(); i++) {
                Sheet sheet = workbook.getSheetAt(i);
                
                // 遍历所有单元格
                for (Row row : sheet) {
                    for (Cell cell : row) {
                        if (cell.getCellType() == CellType.STRING) {
                            String cellValue = cell.getStringCellValue();
                            Matcher matcher = pattern.matcher(cellValue);
                            while (matcher.find()) {
                                fields.add(matcher.group(1));
                            }
                        }
                    }
                }
            }
        }
    }
    
    // 获取文件扩展名
    private String getFileExtension(String fileName) {
        int lastDotIndex = fileName.lastIndexOf('.');
        return lastDotIndex > 0 ? fileName.substring(lastDotIndex) : "";
    }
    
    // 获取不带扩展名的文件名
    private String getFileNameWithoutExtension(String fileName) {
        int lastDotIndex = fileName.lastIndexOf('.');
        return lastDotIndex > 0 ? fileName.substring(0, lastDotIndex) : fileName;
    }
}
```

#### 2.4.3 模板数据处理

`TemplateDataProcessor.java`负责处理模板数据：

```java
public class TemplateDataProcessor {
    // 从Excel文件加载数据
    public Map<String, Object> loadDataFromExcel(String excelFilePath) throws IOException {
        Map<String, Object> data = new HashMap<>();
        
        try (FileInputStream fis = new FileInputStream(excelFilePath);
             Workbook workbook = new XSSFWorkbook(fis)) {
            
            // 遍历所有工作表
            for (int sheetIndex = 0; sheetIndex < workbook.getNumberOfSheets(); sheetIndex++) {
                Sheet sheet = workbook.getSheetAt(sheetIndex);
                String sheetName = sheet.getSheetName();
                
                // 获取标题行
                Row headerRow = sheet.getRow(0);
                if (headerRow == null) continue;
                
                // 根据工作表类型处理数据
                if (isDetailSheet(sheetName)) {
                    // 处理为列表型数据
                    List<Map<String, Object>> detailsList = processDetailSheet(sheet, headerRow);
                    data.put(sheetName, detailsList);
                } else {
                    // 处理为键值对型数据
                    Map<String, Object> sheetData = processKeyValueSheet(sheet);
                    data.put(sheetName, sheetData);
                }
            }
        }
        
        return data;
    }
    
    // 从JSON文件加载数据
    public Map<String, Object> loadDataFromJson(String jsonFilePath) throws IOException {
        ObjectMapper mapper = new ObjectMapper();
        return mapper.readValue(new File(jsonFilePath), new TypeReference<Map<String, Object>>() {});
    }
    
    // 判断工作表是否为详情表（包含多行数据）
    private boolean isDetailSheet(String sheetName) {
        return sheetName.endsWith("List") || sheetName.endsWith("Details");
    }
    
    // 处理详情表（多行数据）
    private List<Map<String, Object>> processDetailSheet(Sheet sheet, Row headerRow) {
        List<Map<String, Object>> detailsList = new ArrayList<>();
        
        // 获取标题
        List<String> headers = new ArrayList<>();
        for (Cell cell : headerRow) {
            if (cell.getCellType() == CellType.STRING) {
                headers.add(cell.getStringCellValue());
            } else {
                headers.add("Column" + cell.getColumnIndex());
            }
        }
        
        // 处理数据行
        for (int rowIndex = 1; rowIndex <= sheet.getLastRowNum(); rowIndex++) {
            Row dataRow = sheet.getRow(rowIndex);
            if (dataRow == null) continue;
            
            Map<String, Object> rowData = new HashMap<>();
            
            // 填充行数据
            for (int colIndex = 0; colIndex < headers.size(); colIndex++) {
                Cell cell = dataRow.getCell(colIndex);
                if (cell == null) continue;
                
                String header = headers.get(colIndex);
                Object value = getCellValue(cell);
                
                rowData.put(header, value);
            }
            
            detailsList.add(rowData);
        }
        
        return detailsList;
    }
    
    // 处理键值对表（每行为一个键值对）
    private Map<String, Object> processKeyValueSheet(Sheet sheet) {
        Map<String, Object> sheetData = new HashMap<>();
        
        // 遍历所有行
        for (int rowIndex = 0; rowIndex <= sheet.getLastRowNum(); rowIndex++) {
            Row row = sheet.getRow(rowIndex);
            if (row == null) continue;
            
            // 获取键和值
            Cell keyCell = row.getCell(0);
            Cell valueCell = row.getCell(1);
            
            if (keyCell != null && keyCell.getCellType() == CellType.STRING) {
                String key = keyCell.getStringCellValue();
                
                if (valueCell != null) {
                    Object value = getCellValue(valueCell);
                    sheetData.put(key, value);
                }
            }
        }
        
        return sheetData;
    }
    
    // 获取单元格的值
    private Object getCellValue(Cell cell) {
        switch (cell.getCellType()) {
            case STRING:
                return cell.getStringCellValue();
            case NUMERIC:
                if (DateUtil.isCellDateFormatted(cell)) {
                    return cell.getDateCellValue();
                } else {
                    // 避免数字被转成科学计数法
                    return String.valueOf(cell.getNumericCellValue());
                }
            case BOOLEAN:
                return cell.getBooleanCellValue();
            case FORMULA:
                try {
                    return cell.getStringCellValue();
                } catch (Exception e) {
                    try {
                        return cell.getNumericCellValue();
                    } catch (Exception ex) {
                        return "";
                    }
                }
            default:
                return "";
        }
    }
}
```

#### 2.4.4 文档生成控制器

`DocumentGeneratorController.java`负责处理用户界面交互：

```java
public class DocumentGeneratorController {
    @FXML private ComboBox<String> templateTypeComboBox;
    @FXML private ComboBox<TemplateInfo> templateComboBox;
    @FXML private TextField dataFilePathField;
    @FXML private Button browseButton;
    @FXML private Button generateButton;
    @FXML private ListView<String> fieldListView;
    @FXML private TextArea previewTextArea;
    
    private TemplateManager templateManager = new TemplateManager();
    private DocumentGenerator documentGenerator = new DocumentGenerator();
    private TemplateDataProcessor dataProcessor = new TemplateDataProcessor();
    
    private ObservableList<TemplateInfo> wordTemplates;
    private ObservableList<TemplateInfo> excelTemplates;
    
    @FXML
    public void initialize() {
        // 初始化模板类型下拉框
        templateTypeComboBox.getItems().addAll("Word文档", "Excel表格");
        
        // 加载模板
        wordTemplates = FXCollections.observableArrayList(templateManager.getWordTemplates());
        excelTemplates = FXCollections.observableArrayList(templateManager.getExcelTemplates());
        
        // 设置模板类型变更监听
        templateTypeComboBox.getSelectionModel().selectedItemProperty().addListener(
            (obs, oldVal, newVal) -> {
                if ("Word文档".equals(newVal)) {
                    templateComboBox.setItems(wordTemplates);
                } else if ("Excel表格".equals(newVal)) {
                    templateComboBox.setItems(excelTemplates);
                }
                
                if (templateComboBox.getItems().size() > 0) {
                    templateComboBox.getSelectionModel().select(0);
                }
            }
        );
        
        // 设置模板选择监听
        templateComboBox.getSelectionModel().selectedItemProperty().addListener(
            (obs, oldVal, newVal) -> {
                if (newVal != null) {
                    updateFieldsList(newVal);
                }
            }
        );
        
        // 默认选择Word文档
        templateTypeComboBox.getSelectionModel().select(0);
    }
    
    // 更新字段列表
    private void updateFieldsList(TemplateInfo templateInfo) {
        if (templateInfo != null) {
            fieldListView.getItems().clear();
            fieldListView.getItems().addAll(templateInfo.getFields());
        }
    }
    
    // 浏览按钮点击事件
    @FXML
    private void handleBrowse() {
        FileChooser fileChooser = new FileChooser();
        fileChooser.setTitle("选择数据文件");
        
        // 根据模板类型设置文件过滤器
        if ("Word文档".equals(templateTypeComboBox.getSelectionModel().getSelectedItem())) {
            fileChooser.getExtensionFilters().add(
                new FileChooser.ExtensionFilter("Excel或JSON文件", "*.xlsx", "*.xls", "*.json")
            );
        } else {
            fileChooser.getExtensionFilters().add(
                new FileChooser.ExtensionFilter("Excel或JSON文件", "*.xlsx", "*.xls", "*.json")
            );
        }
        
        // 显示文件选择对话框
        File file = fileChooser.showOpenDialog(browseButton.getScene().getWindow());
        if (file != null) {
            dataFilePathField.setText(file.getAbsolutePath());
            
            // 加载预览数据
            try {
                Map<String, Object> data = loadData(file.getAbsolutePath());
                updatePreview(data);
            } catch (IOException e) {
                showAlert("加载数据失败: " + e.getMessage());
            }
        }
    }
    
    // 生成按钮点击事件
    @FXML
    private void handleGenerate() {
        // 获取选中的模板
        TemplateInfo selectedTemplate = templateComboBox.getSelectionModel().getSelectedItem();
        if (selectedTemplate == null) {
            showAlert("请选择模板");
            return;
        }
        
        // 获取数据文件路径
        String dataFilePath = dataFilePathField.getText().trim();
        if (dataFilePath.isEmpty()) {
            showAlert("请选择数据文件");
            return;
        }
        
        try {
            // 加载数据
            Map<String, Object> data = loadData(dataFilePath);
            
            // 生成文档
            String templateType = templateTypeComboBox.getSelectionModel().getSelectedItem();
            if ("Word文档".equals(templateType)) {
                documentGenerator.generateWordDocument(selectedTemplate.getName(), data);
            } else if ("Excel表格".equals(templateType)) {
                documentGenerator.generateExcelDocument(selectedTemplate.getName(), data);
            }
            
            showInfo("文档生成成功！");
        } catch (Exception e) {
            showAlert("生成文档失败: " + e.getMessage());
        }
    }
    
    // 加载数据
    private Map<String, Object> loadData(String filePath) throws IOException {
        if (filePath.endsWith(".json")) {
            return dataProcessor.loadDataFromJson(filePath);
        } else {
            return dataProcessor.loadDataFromExcel(filePath);
        }
    }
    
    // 更新预览
    private void updatePreview(Map<String, Object> data) {
        StringBuilder preview = new StringBuilder();
        preview.append("数据预览：\n\n");
        
        // 递归构建数据预览
        buildPreviewText(data, preview, 0);
        
        previewTextArea.setText(preview.toString());
    }
    
    // 递归构建预览文本
    private void buildPreviewText(Object data, StringBuilder preview, int indent) {
        String indentStr = " ".repeat(indent * 2);
        
        if (data instanceof Map) {
            Map<?, ?> map = (Map<?, ?>) data;
            for (Map.Entry<?, ?> entry : map.entrySet()) {
                preview.append(indentStr).append(entry.getKey()).append(": ");
                
                if (entry.getValue() instanceof Map || entry.getValue() instanceof List) {
                    preview.append("\n");
                    buildPreviewText(entry.getValue(), preview, indent + 1);
                } else {
                    preview.append(entry.getValue()).append("\n");
                }
            }
        } else if (data instanceof List) {
            List<?> list = (List<?>) data;
            for (int i = 0; i < list.size(); i++) {
                preview.append(indentStr).append("[").append(i).append("]: ");
                
                if (list.get(i) instanceof Map || list.get(i) instanceof List) {
                    preview.append("\n");
                    buildPreviewText(list.get(i), preview, indent + 1);
                } else {
                    preview.append(list.get(i)).append("\n");
                }
            }
        }
    }
    
    // 显示提示信息
    private void showInfo(String message) {
        Alert alert = new Alert(Alert.AlertType.INFORMATION);
        alert.setTitle("信息");
        alert.setHeaderText(null);
        alert.setContentText(message);
        alert.showAndWait();
    }
    
    // 显示警告信息
    private void showAlert(String message) {
        Alert alert = new Alert(Alert.AlertType.WARNING);
        alert.setTitle("警告");
        alert.setHeaderText(null);
        alert.setContentText(message);
        alert.showAndWait();
    }
}
```

### 2.5 文本纠错模块

#### 2.5.1 核心算法

文本纠错模块实现了两种纠错方式：
1. 基于规则的本地替换
2. 通过API调用的智能纠错

本地替换规则存储在`ReplacementRule`对象中，每条规则包含原始文本、替换文本和匹配条件。这种方式适合处理固定的、可预测的错误，如数字的中文大写转换错误。

API智能纠错则通过调用外部服务，如百度的自然语言处理API，来检测和修正更复杂的语法错误和上下文相关的拼写错误。

文本纠错的核心实现如下：

```java
public class TextCorrector {
    // 替换规则列表
    private static final List<ReplacementRule> rules = new ArrayList<>();
    
    static {
        // 添加替换规则
        rules.add(new ReplacementRule("零", "零零", "零零零"));
        rules.add(new ReplacementRule("一", "壹", "一一"));
        rules.add(new ReplacementRule("二", "贰", "二二"));
        rules.add(new ReplacementRule("三", "叁", "三三"));
        rules.add(new ReplacementRule("四", "肆", "四四"));
        rules.add(new ReplacementRule("五", "伍", "五五"));
        rules.add(new ReplacementRule("六", "陆", "六六"));
        rules.add(new ReplacementRule("七", "柒", "七七"));
        rules.add(new ReplacementRule("八", "捌", "八八"));
        rules.add(new ReplacementRule("九", "玖", "九九"));
        rules.add(new ReplacementRule("十", "拾", "十十"));
        rules.add(new ReplacementRule("百", "佰", "百百"));
        rules.add(new ReplacementRule("千", "仟", "千千"));
        rules.add(new ReplacementRule("万", "万", "万万"));
        rules.add(new ReplacementRule("亿", "亿", "亿亿"));
        rules.add(new ReplacementRule("角", "角", "角角"));
        rules.add(new ReplacementRule("分", "分", "分分"));
        rules.add(new ReplacementRule("整", "整", "整整"));
    }
    
    // 纠错并替换文本
    public String correctText(String text) {
        String result = text;
        
        for (ReplacementRule rule : rules) {
            result = result.replaceAll(rule.getOriginal(), rule.getReplacement());
        }
        
        return result;
    }
    
    // API智能纠错
    public CorrectionResult correctTextWithAPI(String text) throws IOException {
        // 创建API请求参数
        Map<String, Object> params = new HashMap<>();
        params.put("text", text);
        params.put("token", apiToken);
        
        // 发送API请求
        String response = HttpUtils.post(API_URL, params);
        
        // 解析API响应
        ObjectMapper mapper = new ObjectMapper();
        Map<String, Object> result = mapper.readValue(response, Map.class);
        
        // 构建纠错结果
        CorrectionResult correctionResult = new CorrectionResult();
        correctionResult.setOriginalText(text);
        
        if (result.containsKey("result")) {
            Map<String, Object> resultMap = (Map<String, Object>) result.get("result");
            String correctedText = (String) resultMap.get("correct_text");
            correctionResult.setCorrectedText(correctedText);
            
            // 解析错误项
            List<Map<String, Object>> itemArr = (List<Map<String, Object>>) resultMap.get("item_arr");
            if (itemArr != null) {
                for (Map<String, Object> item : itemArr) {
                    Correction correction = new Correction();
                    correction.setOriginal((String) item.get("ori_frag"));
                    correction.setCorrected((String) item.get("correct_frag"));
                    correction.setPosition((int) item.get("begin_pos"));
                    correction.setType((String) item.get("type"));
                    
                    correctionResult.addCorrection(correction);
                }
            }
        }
        
        return correctionResult;
    }
}
```

#### 2.5.2 用户界面设计

用户界面分为四个主要部分：
1. 原始文本输入区
2. 纠错后文本显示区
3. 错误列表显示区
4. 历史记录区

用户可以输入或粘贴文本，点击"纠错"按钮后，系统会执行规则匹配和API调用，然后在纠错文本区显示修正后的文本，同时在错误列表区标注出所有被修改的内容及其原因。

文本纠错控制器的主要实现：

```java
public class TextCorrectorController {
    @FXML private TextArea originalTextArea;
    @FXML private TextArea correctedTextArea;
    @FXML private Button correctButton;
    @FXML private ListView<String> historyListView;
    @FXML private TableView<Correction> errorsTableView;
    
    private TextCorrector corrector = new TextCorrector();
    private ObservableList<String> correctionHistory = FXCollections.observableArrayList();
    private ObservableList<Correction> corrections = FXCollections.observableArrayList();
    
    @FXML
    public void initialize() {
        // 绑定历史记录列表
        historyListView.setItems(correctionHistory);
        
        // 绑定错误列表
        errorsTableView.setItems(corrections);
        
        // 添加输入验证
        originalTextArea.textProperty().addListener((obs, oldText, newText) -> {
            validateOriginalText(newText);
        });
        
        // 加载保存的历史记录
        loadCorrectionHistory();
    }
    
    // 校对按钮事件
    @FXML
    private void handleCorrect() {
        try {
            String originalText = originalTextArea.getText().trim();
            if (originalText.isEmpty()) {
                showAlert("请输入要校对的文本");
                return;
            }
            
            // 执行纠错
            CorrectionResult result = corrector.correctTextWithAPI(originalText);
            
            // 显示纠错结果
            correctedTextArea.setText(result.getCorrectedText());
            
            // 更新错误列表
            corrections.clear();
            corrections.addAll(result.getCorrections());
            
            // 记录校对历史
            addToHistory(String.format("校对文本: %s", 
                originalText.length() > 20 ? originalText.substring(0, 20) + "..." : originalText));
        } catch (Exception e) {
            showAlert("校对出错: " + e.getMessage());
        }
    }
    
    // 其他方法...
}
```

#### 2.5.3 自定义规则管理

用户可以通过规则管理界面添加、编辑和删除自定义替换规则。每条规则支持以下属性：
- 原始文本（支持正则表达式）
- 替换文本
- 规则描述（可选）
- 启用/禁用状态

规则按照添加顺序执行，用户可以调整规则优先级。所有规则存储在本地数据库中，可以导入和导出。

自定义规则类：

```java
public class ReplacementRule {
    private Integer id;
    private String original;       // 原始文本（可使用正则表达式）
    private String replacement;    // 替换文本
    private String description;    // 规则描述
    private boolean enabled;       // 是否启用
    private int priority;         // 优先级（执行顺序）
    
    // 构造函数、getter和setter方法
    // ...
    
    // 应用规则
    public String apply(String text) {
        if (!enabled) {
            return text;
        }
        
        return text.replaceAll(original, replacement);
    }
}
```

#### 2.5.4 性能优化

为了提高大文本处理性能，模块实现了以下优化：
1. 对规则进行预编译，避免重复解析正则表达式
2. 按块处理文本，避免一次性加载过大内容
3. 通过并行处理提高API请求效率
4. 使用本地缓存存储常见纠错结果

性能优化实现：

```java
public class TextCorrector {
    // 规则缓存，预编译正则表达式
    private static final Map<String, Pattern> patternCache = new HashMap<>();
    
    // 按块处理文本
    public CorrectionResult correctLargeText(String text) {
        // 文本太长时分块处理
        if (text.length() > MAX_CHUNK_SIZE) {
            return processTextInChunks(text);
        } else {
            return correctTextWithAPI(text);
        }
    }
    
    // 分块处理文本
    private CorrectionResult processTextInChunks(String text) {
        // 按句号、问号等分割文本
        String[] chunks = text.split("(?<=[。？！.?!]\\s*)");
        
        // 创建总结果
        CorrectionResult finalResult = new CorrectionResult();
        finalResult.setOriginalText(text);
        
        // 处理每个块
        StringBuilder correctedText = new StringBuilder();
        int offset = 0;
        
        for (String chunk : chunks) {
            // 处理单个块
            CorrectionResult chunkResult = correctTextWithAPI(chunk);
            
            // 添加到总结果
            correctedText.append(chunkResult.getCorrectedText());
            
            // 调整错误项的位置偏移
            for (Correction correction : chunkResult.getCorrections()) {
                correction.setPosition(correction.getPosition() + offset);
                finalResult.addCorrection(correction);
            }
            
            // 更新偏移量
            offset += chunk.length();
        }
        
        finalResult.setCorrectedText(correctedText.toString());
        return finalResult;
    }
}
```

### 3. Vue实现方案

#### 3.1 架构设计

将现有的Java/JavaFX应用迁移到Vue，架构将有以下变化：

1. **前端架构**：
   - 使用Vue.js 3.x作为前端框架
   - 使用Element Plus作为UI组件库
   - 使用Vue Router进行路由管理
   - 使用Pinia进行状态管理
   - 使用Axios进行HTTP请求
   - 使用TypeScript增强类型安全性

2. **后端架构**：
   - 保持H2数据库作为本地数据存储
   - 添加Express.js作为后端服务
   - 通过RESTful API进行通信
   - 实现H2数据库和Java逻辑的Node.js版本

3. **部署方式**：
   - 使用Electron打包为跨平台桌面应用
   - 支持Web版部署
   - 支持PWA离线使用

#### 3.2 数据模型对应

以下是将Java数据模型转换为TypeScript的示例：

1. 项目模型：

```typescript
// 项目状态枚举
enum ProjectStatus {
  REGISTRATION = '报名中',
  REVIEW = '审核中',
  FINISHED = '已结束',
  UNKNOWN = '未知'
}

// 项目接口
interface Project {
  id?: number;
  name: string;
  reviewPeriod?: number;
  onlineDate?: Date;
  registrationPeriod?: number;
  registrationEndDate?: Date;
  earliestReviewDate?: Date;
  expectedReviewTime?: number;
  expertReviewTime?: number;
  remark?: string;
}

// 项目类实现
class ProjectModel implements Project {
  id?: number;
  name: string;
  reviewPeriod?: number;
  onlineDate?: Date;
  registrationPeriod?: number;
  registrationEndDate?: Date;
  earliestReviewDate?: Date;
  expectedReviewTime?: number;
  expertReviewTime?: number;
  remark?: string;

  constructor(project: Project) {
    Object.assign(this, project);
  }

  // 计算项目状态
  getStatus(): ProjectStatus {
    const today = new Date();
    
    if (this.getExpectedReviewEndDate() && today > this.getExpectedReviewEndDate()!) {
      return ProjectStatus.FINISHED;
    }
    
    if (this.registrationEndDate && today > this.registrationEndDate) {
      if (!this.getExpectedReviewEndDate() || today <= this.getExpectedReviewEndDate()!) {
        return ProjectStatus.REVIEW;
      }
    }
    
    if (!this.registrationEndDate || today <= this.registrationEndDate) {
      return ProjectStatus.REGISTRATION;
    }
    
    return ProjectStatus.UNKNOWN;
  }

  // 计算预计审核结束日期
  getExpectedReviewEndDate(): Date | null {
    if (!this.earliestReviewDate || !this.expectedReviewTime) {
      return null;
    }
    return this.addWorkingDays(this.earliestReviewDate, this.expectedReviewTime);
  }

  // 添加工作日
  private addWorkingDays(date: Date, days: number): Date {
    let result = new Date(date);
    let addedDays = 0;
    
    while (addedDays < days) {
      result.setDate(result.getDate() + 1);
      if (this.isWorkingDay(result)) {
        addedDays++;
      }
    }
    
    return result;
  }

  // 判断是否为工作日
  private isWorkingDay(date: Date): boolean {
    const dayOfWeek = date.getDay();
    return !(dayOfWeek === 0 || dayOfWeek === 6 || this.isHoliday(date));
  }

  // 判断是否为节假日
  private isHoliday(date: Date): boolean {
    // 调用节假日服务
    return HolidayService.isHoliday(date);
  }
}
```

2. 金额转换模型：

```typescript
class AmountConverter {
  // 数字数组
  private static readonly DIGIT_CHAR = ['零', '壹', '贰', '叁', '肆', '伍', '陆', '柒', '捌', '玖'];
  
  // 单位数组
  private static readonly UNIT_CHAR = ['分', '角', '元', '拾', '佰', '仟', '万', '拾', '佰', '仟', '亿', '拾', '佰', '仟'];
  
  // 数字转中文大写
  convertToChineseUpper(amount: number): string {
    // ... 转换逻辑与Java版本类似 ...
  }
  
  // 中文大写转数字
  convertToNumber(chineseAmount: string): number {
    // ... 转换逻辑与Java版本类似 ...
  }
}
```

3. 文本纠错模型：

```typescript
interface ReplacementRule {
  id?: number;
  original: string;
  replacement: string;
  description?: string;
  enabled: boolean;
  priority: number;
}

interface Correction {
  original: string;
  corrected: string;
  position: number;
  type: string;
}

interface CorrectionResult {
  originalText: string;
  correctedText: string;
  corrections: Correction[];
}

class TextCorrector {
  private rules: ReplacementRule[] = [];
  private apiToken: string = '';
  private readonly API_URL = 'https://aip.baidubce.com/rpc/2.0/nlp/v1/text_correction';
  
  constructor(rules: ReplacementRule[] = []) {
    this.rules = rules;
    this.loadApiToken();
  }
  
  // 加载API令牌
  private async loadApiToken() {
    try {
      // 从配置文件或环境变量加载
      this.apiToken = await ApiService.getToken();
    } catch (error) {
      console.error('Failed to load API token:', error);
    }
  }
  
  // 本地规则纠错
  correctTextWithRules(text: string): string {
    let result = text;
    
    for (const rule of this.rules) {
      if (rule.enabled) {
        result = result.replace(new RegExp(rule.original, 'g'), rule.replacement);
      }
    }
    
    return result;
  }
  
  // API智能纠错
  async correctTextWithAPI(text: string): Promise<CorrectionResult> {
    try {
      const response = await axios.post(this.API_URL, {
        text: text,
        token: this.apiToken
      });
      
      // 解析响应
      const result: CorrectionResult = {
        originalText: text,
        correctedText: text,
        corrections: []
      };
      
      if (response.data && response.data.result) {
        result.correctedText = response.data.result.correct_text;
        
        // 解析错误项
        if (response.data.result.item_arr) {
          for (const item of response.data.result.item_arr) {
            result.corrections.push({
              original: item.ori_frag,
              corrected: item.correct_frag,
              position: item.begin_pos,
              type: item.type
            });
          }
        }
      }
      
      return result;
    } catch (error) {
      console.error('API correction failed:', error);
      throw error;
    }
  }
}
```

## 3. 数据库设计

### 3.1 数据库选型

本项目采用H2作为嵌入式数据库，原因如下：

1. **灵活的数据模型**：
   - 支持动态字段和嵌套文档
   - 适合处理非结构化数据
   - 便于快速迭代和修改

2. **高性能**：
   - 支持高并发读写
   - 适合处理大量数据
   - 支持索引优化

3. **易于扩展**：
   - 支持水平扩展
   - 支持分片集群
   - 便于维护和升级

### 3.2 数据模型设计

#### 3.2.1 项目模型

```java
public class Project {
    private Integer id;              // 项目唯一标识符
    private String name;             // 项目名称
    private Integer reviewPeriod;    // 审核周期(天)
    private LocalDate onlineDate;    // 上线日期
    private Integer registrationPeriod; // 报名周期(天)
    private LocalDate registrationEndDate; // 报名截止日期
    private LocalDate earliestReviewDate;  // 最早审核日期
    private Integer expectedReviewTime;    // 预计审核时间(天)
    private Integer expertReviewTime;      // 专家评审时间
    private String remark;                 // 备注信息
}
```

项目状态计算逻辑：

```java
// 计算项目状态
public String getStatus() {
    LocalDate today = LocalDate.now();
    
    // 已结束：今天已超过预计审核结束日期
    if (getExpectedReviewEndDate() != null && today.isAfter(getExpectedReviewEndDate())) {
        return "已结束";
    }
    
    // 审核中：今天在报名截止日期之后且不晚于预计审核结束日期
    if (registrationEndDate != null && today.isAfter(registrationEndDate) && 
        (getExpectedReviewEndDate() == null || !today.isAfter(getExpectedReviewEndDate()))) {
        return "审核中";
    }
    
    // 报名中：今天不晚于报名截止日期
    if (registrationEndDate == null || !today.isAfter(registrationEndDate)) {
        return "报名中";
    }
    
    return "未知";
}
```

工作日期计算逻辑：

```java
// 计算预计审核结束日期
public LocalDate getExpectedReviewEndDate() {
    if (earliestReviewDate == null || expectedReviewTime == null) {
        return null;
    }
    return addWorkingDays(earliestReviewDate, expectedReviewTime);
}

// 添加工作日
private LocalDate addWorkingDays(LocalDate date, int days) {
    LocalDate result = date;
    int addedDays = 0;
    
    while (addedDays < days) {
        result = result.plusDays(1);
        if (isWorkingDay(result)) {
            addedDays++;
        }
    }
    
    return result;
}

// 判断是否为工作日(非周末且非节假日)
private boolean isWorkingDay(LocalDate date) {
    DayOfWeek dayOfWeek = date.getDayOfWeek();
    return !(dayOfWeek == DayOfWeek.SATURDAY || dayOfWeek == DayOfWeek.SUNDAY ||
             isHoliday(date)); // 需实现isHoliday方法判断法定节假日
}
```

#### 3.2.2 金额转换记录模型

```java
public class ConversionRecord {
    private Integer id;               // 记录唯一标识符
    private String originalAmount;    // 原始金额
    private String convertedAmount;   // 转换后金额
    private String direction;         // 转换方向：'num2zh'或'zh2num'
    private LocalDateTime timestamp;   // 转换时间戳
}
```

#### 3.2.3 文档模板模型

```java
public class Template {
    private Integer id;               // 模板唯一标识符
    private String name;             // 模板名称
    private String type;             // 模板类型：'word'或'excel'
    private String content;          // 模板内容
    private List<Field> fields;       // 字段列表
}

public class Field {
    private Integer id;               // 字段唯一标识符
    private String name;             // 字段名称
    private String key;              // 占位符
    private String type;             // 字段类型：'text'、'number'、'date'或'table'
    private boolean required;        // 是否必填
    private String defaultValue;      // 默认值
    private List<ValidationRule> validationRules; // 验证规则列表
}

public class ValidationRule {
    private String type;             // 验证规则类型：'required'、'format'或'range'
    private String message;          // 验证信息
    private String value;            // 验证值
}
```

#### 3.2.4 文字校对记录模型

```java
public class CorrectionRecord {
    private Integer id;               // 记录唯一标识符
    private String originalText;       // 原始文本
    private String correctedText;      // 校正后文本
    private List<Correction> corrections; // 校正项列表
    private LocalDateTime timestamp;   // 校对时间戳
    private String userId;            // 用户ID
}

public class Correction {
    private String original;           // 原始文本片段
    private String corrected;          // 校正后文本片段
    private int position;             // 在原文中的位置
    private String type;             // 错误类型：拼写错误、语法错误等
}
```

### 3.3 数据访问层设计

#### 3.3.1 数据库连接配置

```java
// config/database.ts
import mongoose from 'mongoose';

const connectDB = async () => {
  try {
    const conn = await mongoose.connect(process.env.MONGODB_URI, {
      useNewUrlParser: true,
      useUnifiedTopology: true,
      useCreateIndex: true
    });
    
    console.log(`MongoDB Connected: ${conn.connection.host}`);
  } catch (error) {
    console.error(`Error: ${error.message}`);
    process.exit(1);
  }
};

export default connectDB;
```

#### 3.3.2 数据模型定义

```java
// models/Project.ts
import mongoose, { Schema, Document } from 'mongoose';

export interface IProject extends Document {
  name: string;
  reviewPeriod: number;
  onlineDate: Date;
  registrationPeriod: number;
  registrationEndDate: Date;
  earliestReviewDate: Date;
  expectedReviewTime: Date;
  expertReviewTime: Date;
  remark: string;
  status: string;
  createdAt: Date;
  updatedAt: Date;
}

const ProjectSchema = new Schema({
  // ... schema definition ...
});

export default mongoose.model<IProject>('Project', ProjectSchema);
```

#### 3.3.3 数据访问服务

```java
// services/ProjectService.ts
import Project, { IProject } from '../models/Project';

export class ProjectService {
  async createProject(projectData: Partial<IProject>): Promise<IProject> {
    const project = new Project(projectData);
    return await project.save();
  }

  async updateProject(id: string, projectData: Partial<IProject>): Promise<IProject> {
    return await Project.findByIdAndUpdate(
      id,
      { ...projectData, updatedAt: new Date() },
      { new: true }
    );
  }

  async deleteProject(id: string): Promise<void> {
    await Project.findByIdAndDelete(id);
  }

  async getProject(id: string): Promise<IProject> {
    return await Project.findById(id);
  }

  async listProjects(query: any = {}): Promise<IProject[]> {
    return await Project.find(query).sort({ createdAt: -1 });
  }

  async getProjectsByDate(date: Date): Promise<IProject[]> {
    return await Project.find({
      $or: [
        { onlineDate: date },
        { registrationEndDate: date },
        { earliestReviewDate: date },
        { expectedReviewTime: date }
      ]
    });
  }
}
```

### 3.4 数据迁移策略

#### 3.4.1 迁移脚本

```java
// scripts/migrate.ts
import mongoose from 'mongoose';
import { ProjectService } from '../services/ProjectService';
import { ConversionService } from '../services/ConversionService';
import { TemplateService } from '../services/TemplateService';
import { CorrectionService } from '../services/CorrectionService';

async function migrate() {
  try {
    // 连接数据库
    await mongoose.connect(process.env.MONGODB_URI);
    
    // 执行迁移
    await Promise.all([
      migrateProjects(),
      migrateConversions(),
      migrateTemplates(),
      migrateCorrections()
    ]);
    
    console.log('Migration completed successfully');
  } catch (error) {
    console.error('Migration failed:', error);
    process.exit(1);
  } finally {
    await mongoose.disconnect();
  }
}

async function migrateProjects() {
  const projectService = new ProjectService();
  // 实现项目数据迁移逻辑
}

async function migrateConversions() {
  const conversionService = new ConversionService();
  // 实现转换记录迁移逻辑
}

async function migrateTemplates() {
  const templateService = new TemplateService();
  // 实现模板数据迁移逻辑
}

async function migrateCorrections() {
  const correctionService = new CorrectionService();
  // 实现校对记录迁移逻辑
}

migrate();
```

#### 3.4.2 数据备份策略

1. **自动备份**：
   - 每天凌晨进行全量备份
   - 每小时进行增量备份
   - 备份文件压缩并加密存储

2. **备份验证**：
   - 定期验证备份文件的完整性
   - 测试备份恢复流程
   - 记录备份日志

3. **备份存储**：
   - 本地存储一份备份
   - 异地存储一份备份
   - 云存储一份备份

### 3.5 数据安全策略

1. **访问控制**：
   - 基于角色的访问控制（RBAC）
   - API访问权限控制
   - 数据访问审计

2. **数据加密**：
   - 传输层加密（TLS）
   - 敏感数据加密存储
   - 密钥管理

3. **数据备份**：
   - 定期备份
   - 多副本存储
   - 灾难恢复

4. **监控告警**：
   - 数据库性能监控
   - 异常访问监控
   - 安全事件告警

## 4. 部署和维护

### 4.1 部署架构

#### 4.1.1 开发环境

```yaml
# docker-compose.dev.yml
version: '3.8'

services:
  frontend:
    build:
      context: ./client
      dockerfile: Dockerfile.dev
    ports:
      - "3000:3000"
    volumes:
      - ./client:/app
      - /app/node_modules
    environment:
      - NODE_ENV=development
      - VITE_API_URL=http://localhost:4000
    depends_on:
      - backend

  backend:
    build:
      context: ./server
      dockerfile: Dockerfile.dev
    ports:
      - "4000:4000"
    volumes:
      - ./server:/app
      - /app/node_modules
    environment:
      - NODE_ENV=development
      - MONGODB_URI=mongodb://mongodb:27017/project_assistant
    depends_on:
      - mongodb

  mongodb:
    image: mongo:latest
    ports:
      - "27017:27017"
    volumes:
      - mongodb_data:/data/db

volumes:
  mongodb_data:
```

#### 4.1.2 生产环境

```yaml
# docker-compose.prod.yml
version: '3.8'

services:
  frontend:
    build:
      context: ./client
      dockerfile: Dockerfile.prod
    ports:
      - "80:80"
    environment:
      - NODE_ENV=production
      - VITE_API_URL=https://api.example.com
    depends_on:
      - backend

  backend:
    build:
      context: ./server
      dockerfile: Dockerfile.prod
    ports:
      - "4000:4000"
    environment:
      - NODE_ENV=production
      - MONGODB_URI=mongodb://mongodb:27017/project_assistant
      - JWT_SECRET=your_jwt_secret
    depends_on:
      - mongodb

  mongodb:
    image: mongo:latest
    ports:
      - "27017:27017"
    volumes:
      - mongodb_data:/data/db
    command: mongod --auth

  nginx:
    image: nginx:alpine
    ports:
      - "443:443"
    volumes:
      - ./nginx/conf.d:/etc/nginx/conf.d
      - ./nginx/ssl:/etc/nginx/ssl
    depends_on:
      - frontend
      - backend

volumes:
  mongodb_data:
```

### 4.2 构建配置

#### 4.2.1 前端构建配置

```javascript
// client/vite.config.ts
import { defineConfig } from 'vite'
import vue from '@vitejs/plugin-vue'
import path from 'path'

export default defineConfig({
  plugins: [vue()],
  resolve: {
    alias: {
      '@': path.resolve(__dirname, 'src')
    }
  },
  build: {
    outDir: 'dist',
    assetsDir: 'assets',
    sourcemap: true,
    rollupOptions: {
      output: {
        manualChunks: {
          'vendor': ['vue', 'vue-router', 'pinia'],
          'element-plus': ['element-plus']
        }
      }
    }
  },
  server: {
    port: 3000,
    proxy: {
      '/api': {
        target: 'http://localhost:4000',
        changeOrigin: true
      }
    }
  }
})
```

#### 4.2.2 后端构建配置

```javascript
// server/package.json
{
  "name": "project-assistant-server",
  "version": "1.0.0",
  "scripts": {
    "start": "node dist/index.js",
    "dev": "nodemon src/index.ts",
    "build": "tsc",
    "test": "jest",
    "lint": "eslint . --ext .ts"
  },
  "dependencies": {
    "express": "^4.18.2",
    "mongoose": "^7.0.0",
    "cors": "^2.8.5",
    "dotenv": "^16.0.3",
    "jsonwebtoken": "^9.0.0",
    "bcryptjs": "^2.4.3"
  },
  "devDependencies": {
    "@types/express": "^4.17.17",
    "@types/node": "^18.15.0",
    "@typescript-eslint/eslint-plugin": "^5.57.0",
    "@typescript-eslint/parser": "^5.57.0",
    "typescript": "^5.0.0",
    "nodemon": "^2.0.22",
    "ts-node": "^10.9.1",
    "jest": "^29.5.0",
    "@types/jest": "^29.5.0",
    "ts-jest": "^29.1.0"
  }
}
```

### 4.3 部署流程

#### 4.3.1 开发环境部署

```bash
# 1. 克隆项目
git clone https://github.com/your-org/project-assistant.git
cd project-assistant

# 2. 安装依赖
cd client && npm install
cd ../server && npm install

# 3. 启动开发环境
docker-compose -f docker-compose.dev.yml up -d
```

#### 4.3.2 生产环境部署

```bash
# 1. 构建前端
cd client
npm run build

# 2. 构建后端
cd ../server
npm run build

# 3. 启动生产环境
docker-compose -f docker-compose.prod.yml up -d
```

### 4.4 监控和维护

#### 4.4.1 日志管理

```typescript
// server/src/utils/logger.ts
import winston from 'winston';

const logger = winston.createLogger({
  level: 'info',
  format: winston.format.combine(
    winston.format.timestamp(),
    winston.format.json()
  ),
  transports: [
    new winston.transports.File({ filename: 'error.log', level: 'error' }),
    new winston.transports.File({ filename: 'combined.log' })
  ]
});

if (process.env.NODE_ENV !== 'production') {
  logger.add(new winston.transports.Console({
    format: winston.format.simple()
  }));
}

export default logger;
```

#### 4.4.2 性能监控

```typescript
// server/src/middleware/monitor.ts
import { Request, Response, NextFunction } from 'express';
import promClient from 'prom-client';

const collectDefaultMetrics = promClient.collectDefaultMetrics;
const Registry = promClient.Registry;
const register = new Registry();

collectDefaultMetrics({ register });

export const metricsMiddleware = async (req: Request, res: Response, next: NextFunction) => {
  const start = Date.now();
  
  res.on('finish', () => {
    const duration = Date.now() - start;
    register.getSingleMetric('http_request_duration_seconds').observe(
      { method: req.method, route: req.route?.path || req.path },
      duration / 1000
    );
  });
  
  next();
};
```

#### 4.4.3 健康检查

```typescript
// server/src/routes/health.ts
import { Router } from 'express';
import mongoose from 'mongoose';

const router = Router();

router.get('/health', async (req, res) => {
  try {
    // 检查数据库连接
    const dbState = mongoose.connection.readyState;
    const dbStatus = dbState === 1 ? 'connected' : 'disconnected';
    
    // 检查内存使用
    const memoryUsage = process.memoryUsage();
    
    res.json({
      status: 'ok',
      timestamp: new Date().toISOString(),
      database: dbStatus,
      memory: {
        heapUsed: memoryUsage.heapUsed,
        heapTotal: memoryUsage.heapTotal,
        external: memoryUsage.external
      }
    });
  } catch (error) {
    res.status(500).json({
      status: 'error',
      message: error.message
    });
  }
});

export default router;
```

### 4.5 备份策略

#### 4.5.1 数据库备份

```bash
#!/bin/bash
# backup.sh

# 设置变量
BACKUP_DIR="/backup"
MONGODB_URI="mongodb://localhost:27017"
DB_NAME="project_assistant"
DATE=$(date +%Y%m%d_%H%M%S)

# 创建备份目录
mkdir -p $BACKUP_DIR

# 执行备份
mongodump --uri=$MONGODB_URI --db=$DB_NAME --out=$BACKUP_DIR/$DATE

# 压缩备份
tar -czf $BACKUP_DIR/$DATE.tar.gz $BACKUP_DIR/$DATE

# 删除原始备份目录
rm -rf $BACKUP_DIR/$DATE

# 保留最近30天的备份
find $BACKUP_DIR -name "*.tar.gz" -mtime +30 -delete
```

#### 4.5.2 配置文件备份

```bash
#!/bin/bash
# config-backup.sh

# 设置变量
BACKUP_DIR="/backup/config"
DATE=$(date +%Y%m%d_%H%M%S)

# 创建备份目录
mkdir -p $BACKUP_DIR

# 备份配置文件
tar -czf $BACKUP_DIR/config_$DATE.tar.gz \
  ./client/.env \
  ./server/.env \
  ./nginx/conf.d \
  ./nginx/ssl

# 保留最近30天的备份
find $BACKUP_DIR -name "*.tar.gz" -mtime +30 -delete
```

### 4.6 更新和回滚

#### 4.6.1 更新流程

```bash
#!/bin/bash
# update.sh

# 1. 拉取最新代码
git pull origin main

# 2. 安装依赖
cd client && npm install
cd ../server && npm install

# 3. 构建应用
cd ../client && npm run build
cd ../server && npm run build

# 4. 备份当前版本
./backup.sh

# 5. 重启服务
docker-compose -f docker-compose.prod.yml down
docker-compose -f docker-compose.prod.yml up -d

# 6. 检查服务状态
./health-check.sh
```

#### 4.6.2 回滚流程

```bash
#!/bin/bash
# rollback.sh

# 1. 停止服务
docker-compose -f docker-compose.prod.yml down

# 2. 恢复备份
tar -xzf /backup/latest.tar.gz -C /

# 3. 重启服务
docker-compose -f docker-compose.prod.yml up -d

# 4. 检查服务状态
./health-check.sh
```

## 5. 安全与性能

### 5.1 安全措施

#### 5.1.1 前端安全

```typescript
// client/src/utils/security.ts
import { ref } from 'vue'
import { useRouter } from 'vue-router'

// XSS防护
export const sanitizeInput = (input: string): string => {
  return input
    .replace(/&/g, '&amp;')
    .replace(/</g, '&lt;')
    .replace(/>/g, '&gt;')
    .replace(/"/g, '&quot;')
    .replace(/'/g, '&#x27;')
    .replace(/\//g, '&#x2F;')
}

// CSRF Token管理
export const useCsrfToken = () => {
  const token = ref<string>('')
  
  const generateToken = async () => {
    try {
      const response = await fetch('/api/csrf-token')
      token.value = await response.json()
    } catch (error) {
      console.error('Failed to generate CSRF token:', error)
    }
  }
  
  return {
    token,
    generateToken
  }
}

// 路由守卫
export const useAuthGuard = () => {
  const router = useRouter()
  
  router.beforeEach((to, from, next) => {
    const token = localStorage.getItem('token')
    if (to.meta.requiresAuth && !token) {
      next('/login')
    } else {
      next()
    }
  })
}
```

#### 5.1.2 后端安全

```typescript
// server/src/middleware/security.ts
import helmet from 'helmet'
import rateLimit from 'express-rate-limit'
import { Request, Response, NextFunction } from 'express'

// 安全头设置
export const securityHeaders = helmet({
  contentSecurityPolicy: {
    directives: {
      defaultSrc: ["'self'"],
      scriptSrc: ["'self'", "'unsafe-inline'"],
      styleSrc: ["'self'", "'unsafe-inline'"],
      imgSrc: ["'self'", 'data:', 'https:'],
      connectSrc: ["'self'", 'https://api.example.com']
    }
  },
  crossOriginEmbedderPolicy: false
})

// 速率限制
export const rateLimiter = rateLimit({
  windowMs: 15 * 60 * 1000, // 15分钟
  max: 100, // 限制每个IP 15分钟内最多100个请求
  message: '请求过于频繁，请稍后再试'
})

// JWT验证中间件
export const jwtAuth = (req: Request, res: Response, next: NextFunction) => {
  try {
    const token = req.headers.authorization?.split(' ')[1]
    if (!token) {
      return res.status(401).json({ message: '未提供认证令牌' })
    }
    
    const decoded = jwt.verify(token, process.env.JWT_SECRET!)
    req.user = decoded
    next()
  } catch (error) {
    res.status(401).json({ message: '无效的认证令牌' })
  }
}
```

### 5.2 性能优化

#### 5.2.1 前端性能优化

```typescript
// client/src/utils/performance.ts
import { onMounted, onUnmounted } from 'vue'

// 性能监控
export const usePerformanceMonitor = () => {
  const metrics = ref({
    fcp: 0, // First Contentful Paint
    lcp: 0, // Largest Contentful Paint
    fid: 0, // First Input Delay
    cls: 0  // Cumulative Layout Shift
  })
  
  onMounted(() => {
    // 监控FCP
    const fcpObserver = new PerformanceObserver((list) => {
      const entries = list.getEntries()
      metrics.value.fcp = entries[0].startTime
    })
    fcpObserver.observe({ entryTypes: ['paint'] })
    
    // 监控LCP
    const lcpObserver = new PerformanceObserver((list) => {
      const entries = list.getEntries()
      metrics.value.lcp = entries[entries.length - 1].startTime
    })
    lcpObserver.observe({ entryTypes: ['largest-contentful-paint'] })
    
    // 监控FID
    if ('PerformanceObserver' in window) {
      const fidObserver = new PerformanceObserver((list) => {
        const entries = list.getEntries()
        metrics.value.fid = entries[0].processingStart - entries[0].startTime
      })
      fidObserver.observe({ entryTypes: ['first-input'] })
    }
    
    // 监控CLS
    let clsValue = 0
    let clsEntries = []
    new PerformanceObserver((entryList) => {
      for (const entry of entryList.getEntries()) {
        if (!entry.hadRecentInput) {
          clsEntries.push(entry)
          clsValue += entry.value
          metrics.value.cls = clsValue
        }
      }
    }).observe({ entryTypes: ['layout-shift'] })
  })
  
  return metrics
}

// 图片懒加载
export const useLazyLoad = () => {
  const lazyLoadImage = (el: HTMLImageElement) => {
    const observer = new IntersectionObserver((entries) => {
      entries.forEach(entry => {
        if (entry.isIntersecting) {
          el.src = el.dataset.src || ''
          observer.unobserve(el)
        }
      })
    })
    observer.observe(el)
  }
  
  return {
    lazyLoadImage
  }
}
```

#### 5.2.2 后端性能优化

```typescript
// server/src/utils/performance.ts
import { promClient } from 'prom-client'
import { Request, Response, NextFunction } from 'express'

// 性能指标收集
const collectDefaultMetrics = promClient.collectDefaultMetrics
const Registry = promClient.Registry
const register = new Registry()

collectDefaultMetrics({ register })

// 请求性能监控中间件
export const performanceMiddleware = async (req: Request, res: Response, next: NextFunction) => {
  const start = Date.now()
  
  res.on('finish', () => {
    const duration = Date.now() - start
    register.getSingleMetric('http_request_duration_seconds').observe(
      { method: req.method, route: req.route?.path || req.path },
      duration / 1000
    )
  })
  
  next()
}

// 缓存中间件
export const cacheMiddleware = (duration: number) => {
  const cache = new Map()
  
  return (req: Request, res: Response, next: NextFunction) => {
    const key = req.originalUrl
    
    if (cache.has(key)) {
      const { data, timestamp } = cache.get(key)
      if (Date.now() - timestamp < duration) {
        return res.json(data)
      }
    }
    
    const originalJson = res.json
    res.json = function(data) {
      cache.set(key, {
        data,
        timestamp: Date.now()
      })
      return originalJson.call(this, data)
    }
    
    next()
  }
}

// 数据库查询优化
export const optimizeQuery = async (query: any) => {
  // 添加索引
  await query.model.collection.createIndex({ field: 1 })
  
  // 限制返回字段
  query.select('field1 field2')
  
  // 使用lean()减少内存使用
  return query.lean()
}
```

### 5.3 错误处理

#### 5.3.1 前端错误处理

```typescript
// client/src/utils/error-handler.ts
import { ref } from 'vue'
import { ElMessage } from 'element-plus'

export const useErrorHandler = () => {
  const error = ref<Error | null>(null)
  
  const handleError = (err: any) => {
    error.value = err
    
    // 显示错误消息
    ElMessage.error({
      message: err.message || '发生错误，请稍后重试',
      duration: 5000
    })
    
    // 记录错误日志
    console.error('Error:', err)
    
    // 发送错误报告
    if (process.env.NODE_ENV === 'production') {
      // 发送到错误收集服务
      reportError(err)
    }
  }
  
  const reportError = (err: Error) => {
    // 实现错误报告逻辑
  }
  
  return {
    error,
    handleError
  }
}
```

#### 5.3.2 后端错误处理

```typescript
// server/src/utils/error-handler.ts
import { Request, Response, NextFunction } from 'express'
import { logger } from './logger'

export class AppError extends Error {
  constructor(
    public statusCode: number,
    message: string,
    public isOperational = true
  ) {
    super(message)
    Object.setPrototypeOf(this, AppError.prototype)
  }
}

export const errorHandler = (
  err: Error,
  req: Request,
  res: Response,
  next: NextFunction
) => {
  if (err instanceof AppError) {
    logger.error({
      message: err.message,
      stack: err.stack,
      path: req.path,
      method: req.method,
      statusCode: err.statusCode
    })
    
    return res.status(err.statusCode).json({
      status: 'error',
      message: err.message
    })
  }
  
  // 处理未知错误
  logger.error({
    message: err.message,
    stack: err.stack,
    path: req.path,
    method: req.method
  })
  
  return res.status(500).json({
    status: 'error',
    message: '服务器内部错误'
  })
}
```

### 5.4 数据安全

#### 5.4.1 数据加密

```typescript
// server/src/utils/encryption.ts
import crypto from 'crypto'

export const encrypt = (text: string): string => {
  const iv = crypto.randomBytes(16)
  const cipher = crypto.createCipheriv(
    'aes-256-gcm',
    Buffer.from(process.env.ENCRYPTION_KEY!),
    iv
  )
  
  let encrypted = cipher.update(text, 'utf8', 'hex')
  encrypted += cipher.final('hex')
  
  const authTag = cipher.getAuthTag()
  
  return `${iv.toString('hex')}:${encrypted}:${authTag.toString('hex')}`
}

export const decrypt = (encryptedText: string): string => {
  const [ivHex, encrypted, authTagHex] = encryptedText.split(':')
  const iv = Buffer.from(ivHex, 'hex')
  const authTag = Buffer.from(authTagHex, 'hex')
  
  const decipher = crypto.createDecipheriv(
    'aes-256-gcm',
    Buffer.from(process.env.ENCRYPTION_KEY!),
    iv
  )
  
  decipher.setAuthTag(authTag)
  
  let decrypted = decipher.update(encrypted, 'hex', 'utf8')
  decrypted += decipher.final('utf8')
  
  return decrypted
}
```

#### 5.4.2 数据备份

```typescript
// server/src/utils/backup.ts
import { exec } from 'child_process'
import { promisify } from 'util'
import { logger } from './logger'

const execAsync = promisify(exec)

export const backupDatabase = async () => {
  try {
    const timestamp = new Date().toISOString().replace(/[:.]/g, '-')
    const backupPath = `/backup/db-${timestamp}.gz`
    
    // 执行MongoDB备份
    await execAsync(`mongodump --uri="${process.env.MONGODB_URI}" --gzip --archive="${backupPath}"`)
    
    logger.info(`Database backup created: ${backupPath}`)
    
    // 清理旧备份
    await cleanupOldBackups()
    
    return backupPath
  } catch (error) {
    logger.error('Database backup failed:', error)
    throw error
  }
}

const cleanupOldBackups = async () => {
  try {
    // 删除30天前的备份
    await execAsync('find /backup -name "db-*.gz" -mtime +30 -delete')
    logger.info('Old backups cleaned up')
  } catch (error) {
    logger.error('Failed to cleanup old backups:', error)
  }
}
```

## 6. 未来扩展计划

### 6.1 功能扩展

#### 6.1.1 多用户支持

```typescript
// server/src/models/User.ts
import mongoose from 'mongoose'
import bcrypt from 'bcryptjs'

const userSchema = new mongoose.Schema({
  username: {
    type: String,
    required: true,
    unique: true
  },
  email: {
    type: String,
    required: true,
    unique: true
  },
  password: {
    type: String,
    required: true
  },
  role: {
    type: String,
    enum: ['admin', 'user', 'guest'],
    default: 'user'
  },
  permissions: [{
    type: String,
    enum: ['project:read', 'project:write', 'doc:read', 'doc:write']
  }],
  createdAt: {
    type: Date,
    default: Date.now
  }
})

// 密码加密中间件
userSchema.pre('save', async function(next) {
  if (!this.isModified('password')) return next()
  this.password = await bcrypt.hash(this.password, 10)
  next()
})

export const User = mongoose.model('User', userSchema)
```

#### 6.1.2 云同步功能

```typescript
// client/src/composables/useSync.ts
import { ref, onMounted, onUnmounted } from 'vue'
import { useStore } from 'pinia'

export const useSync = () => {
  const store = useStore()
  const isSyncing = ref(false)
  const lastSyncTime = ref<Date | null>(null)
  
  const syncData = async () => {
    if (isSyncing.value) return
    
    try {
      isSyncing.value = true
      
      // 同步项目数据
      await syncProjects()
      
      // 同步文档模板
      await syncTemplates()
      
      // 同步用户设置
      await syncSettings()
      
      lastSyncTime.value = new Date()
    } catch (error) {
      console.error('Sync failed:', error)
    } finally {
      isSyncing.value = false
    }
  }
  
  // 自动同步
  onMounted(() => {
    const syncInterval = setInterval(syncData, 5 * 60 * 1000) // 每5分钟同步一次
    onUnmounted(() => clearInterval(syncInterval))
  })
  
  return {
    isSyncing,
    lastSyncTime,
    syncData
  }
}
```

#### 6.1.3 移动端适配

```typescript
// client/src/composables/useResponsive.ts
import { ref, onMounted, onUnmounted } from 'vue'

export const useResponsive = () => {
  const isMobile = ref(false)
  const isTablet = ref(false)
  const isDesktop = ref(false)
  
  const checkDevice = () => {
    const width = window.innerWidth
    isMobile.value = width < 768
    isTablet.value = width >= 768 && width < 1024
    isDesktop.value = width >= 1024
  }
  
  onMounted(() => {
    checkDevice()
    window.addEventListener('resize', checkDevice)
  })
  
  onUnmounted(() => {
    window.removeEventListener('resize', checkDevice)
  })
  
  return {
    isMobile,
    isTablet,
    isDesktop
  }
}
```

### 6.2 技术升级

#### 6.2.1 框架升级

```json
// client/package.json
{
  "dependencies": {
    "vue": "^4.0.0",
    "vue-router": "^5.0.0",
    "pinia": "^3.0.0",
    "element-plus": "^3.0.0",
    "vite": "^5.0.0",
    "typescript": "^5.0.0"
  }
}

// server/package.json
{
  "dependencies": {
    "express": "^5.0.0",
    "mongoose": "^8.0.0",
    "typescript": "^5.0.0",
    "node": "^20.0.0"
  }
}
```

#### 6.2.2 AI集成

```typescript
// server/src/services/ai-service.ts
import OpenAI from 'openai'

export class AIService {
  private openai: OpenAI
  
  constructor() {
    this.openai = new OpenAI({
      apiKey: process.env.OPENAI_API_KEY
    })
  }
  
  async generateText(prompt: string): Promise<string> {
    const completion = await this.openai.chat.completions.create({
      model: "gpt-4",
      messages: [{ role: "user", content: prompt }]
    })
    
    return completion.choices[0].message.content
  }
  
  async analyzeDocument(content: string): Promise<{
    summary: string,
    keywords: string[],
    sentiment: 'positive' | 'negative' | 'neutral'
  }> {
    // 实现文档分析逻辑
    return {
      summary: '',
      keywords: [],
      sentiment: 'neutral'
    }
  }
}
```

### 6.3 性能优化

#### 6.3.1 前端优化

```typescript
// client/src/composables/usePerformance.ts
import { ref, onMounted } from 'vue'

export const usePerformance = () => {
  const metrics = ref({
    loadTime: 0,
    firstPaint: 0,
    domInteractive: 0,
    domComplete: 0
  })
  
  onMounted(() => {
    // 收集性能指标
    const timing = window.performance.timing
    metrics.value = {
      loadTime: timing.loadEventEnd - timing.navigationStart,
      firstPaint: timing.responseEnd - timing.requestStart,
      domInteractive: timing.domInteractive - timing.navigationStart,
      domComplete: timing.domComplete - timing.navigationStart
    }
    
    // 发送性能数据到服务器
    reportPerformance(metrics.value)
  })
  
  return metrics
}
```

#### 6.3.2 后端优化

```typescript
// server/src/middleware/cache.ts
import { Request, Response, NextFunction } from 'express'
import Redis from 'ioredis'

const redis = new Redis(process.env.REDIS_URL)

export const cacheMiddleware = (duration: number) => {
  return async (req: Request, res: Response, next: NextFunction) => {
    const key = `cache:${req.originalUrl}`
    
    try {
      const cachedData = await redis.get(key)
      if (cachedData) {
        return res.json(JSON.parse(cachedData))
      }
      
      const originalJson = res.json
      res.json = function(data) {
        redis.setex(key, duration, JSON.stringify(data))
        return originalJson.call(this, data)
      }
      
      next()
    } catch (error) {
      next(error)
    }
  }
}
```

### 6.4 API扩展

#### 6.4.1 RESTful API

```typescript
// server/src/routes/api.ts
import { Router } from 'express'
import { ProjectController } from '../controllers/project'
import { DocumentController } from '../controllers/document'
import { auth } from '../middleware/auth'

const router = Router()

// 项目相关API
router.get('/projects', auth, ProjectController.list)
router.post('/projects', auth, ProjectController.create)
router.get('/projects/:id', auth, ProjectController.get)
router.put('/projects/:id', auth, ProjectController.update)
router.delete('/projects/:id', auth, ProjectController.delete)

// 文档相关API
router.get('/documents', auth, DocumentController.list)
router.post('/documents', auth, DocumentController.create)
router.get('/documents/:id', auth, DocumentController.get)
router.put('/documents/:id', auth, DocumentController.update)
router.delete('/documents/:id', auth, DocumentController.delete)

export default router
```

#### 6.4.2 WebSocket支持

```typescript
// server/src/websocket/index.ts
import { Server } from 'socket.io'
import { Server as HttpServer } from 'http'

export const setupWebSocket = (httpServer: HttpServer) => {
  const io = new Server(httpServer, {
    cors: {
      origin: process.env.CLIENT_URL,
      methods: ['GET', 'POST']
    }
  })
  
  io.on('connection', (socket) => {
    console.log('Client connected')
    
    socket.on('join-project', (projectId: string) => {
      socket.join(`project:${projectId}`)
    })
    
    socket.on('project-update', (data) => {
      io.to(`project:${data.projectId}`).emit('project-updated', data)
    })
    
    socket.on('disconnect', () => {
      console.log('Client disconnected')
    })
  })
  
  return io
}
```

### 6.5 部署优化

#### 6.5.1 容器化部署

```yaml
# docker-compose.yml
version: '3.8'

services:
  frontend:
    build:
      context: ./client
      dockerfile: Dockerfile.prod
    ports:
      - "80:80"
    environment:
      - NODE_ENV=production
      - VITE_API_URL=http://backend:4000
    depends_on:
      - backend

  backend:
    build:
      context: ./server
      dockerfile: Dockerfile.prod
    ports:
      - "4000:4000"
    environment:
      - NODE_ENV=production
      - MONGODB_URI=mongodb://mongodb:27017/project_assistant
      - REDIS_URL=redis://redis:6379
    depends_on:
      - mongodb
      - redis

  mongodb:
    image: mongo:latest
    ports:
      - "27017:27017"
    volumes:
      - mongodb_data:/data/db

  redis:
    image: redis:alpine
    ports:
      - "6379:6379"
    volumes:
      - redis_data:/data

volumes:
  mongodb_data:
  redis_data:
```

#### 6.5.2 CI/CD配置

```yaml
# .github/workflows/main.yml
name: CI/CD

on:
  push:
    branches: [ main ]
  pull_request:
    branches: [ main ]

jobs:
  build:
    runs-on: ubuntu-latest
    
    steps:
    - uses: actions/checkout@v2
    
    - name: Setup Node.js
      uses: actions/setup-node@v2
      with:
        node-version: '20'
        
    - name: Install Dependencies
      run: |
        cd client && npm install
        cd ../server && npm install
        
    - name: Build
      run: |
        cd client && npm run build
        cd ../server && npm run build
        
    - name: Run Tests
      run: |
        cd client && npm run test
        cd ../server && npm run test
        
    - name: Deploy
      if: github.ref == 'refs/heads/main'
      run: |
        # 部署步骤
        echo "Deploying..."
```

## 9. 完整代码向Vue迁移策略

基于对原始Java和JavaFX代码的详细分析，将ProjectAssistant迁移到Vue实现需要以下策略：

### 9.1 架构转换

**原架构**：
- 前端：JavaFX (MVC架构)
- 数据库：本地H2数据库
- 存储：本地文件系统
- 部署：单机桌面应用

**新架构**：
- 前端：Vue.js + Element Plus
- 后端：Express/Node.js REST API
- 数据库：仍保留H2数据库
- 部署：Electron桌面应用 + 可选Web版本

### 9.2 核心业务逻辑转换

各模块的核心算法逻辑基本保留，主要是语言转换：

1. **项目管理模块**：
   - 工作日计算逻辑
   - 项目状态判断逻辑
   - 日历可视化组件

2. **金额转换模块**：
   - 数字转中文大写算法
   - 中文大写转数字算法
   - 历史记录管理

3. **文档生成模块**：
   - 模板解析与占位符替换
   - Word/Excel文档生成
   - 数据导入与预览

4. **文本纠错模块**：
   - 规则替换引擎
   - API智能纠错集成
   - 自定义规则管理

### 9.3 用户界面重构

使用Vue组件重构UI，参考原JavaFX设计：

1. **布局组件**：
   - 主窗口布局：使用Element Plus的Container组件
   - 模块导航：使用Tabs或Menu组件
   - 响应式设计：支持不同屏幕尺寸

2. **表单组件**：
   - 日期选择器：使用DatePicker组件
   - 数字输入：使用InputNumber组件
   - 数据表格：使用Table组件

3. **可视化组件**：
   - 日历视图：使用FullCalendar或自定义Calendar组件
   - 图表：使用ECharts或Chart.js

### 9.4 数据访问层改造

将直接的数据库访问改为API调用：

1. **REST API设计**：
   - 项目管理API：`/api/projects`
   - 金额转换API：`/api/amount-converter`
   - 文档生成API：`/api/documents`
   - 文本纠错API：`/api/text-corrector`

2. **数据持久化**：
   - 服务端：使用H2数据库
   - 客户端：LocalStorage和IndexedDB缓存

3. **离线支持**：
   - 实现离线数据同步
   - 使用Service Worker缓存API响应

### 9.5 迁移步骤

1. **阶段一：原型设计**
   - 设计Vue组件结构
   - 创建REST API接口文档
   - 开发基础UI组件

2. **阶段二：核心功能实现**
   - 实现核心业务逻辑
   - 构建API服务
   - 连接前后端

3. **阶段三：功能完善**
   - 添加高级特性
   - 优化用户体验
   - 实现离线支持

4. **阶段四：测试与部署**
   - 单元测试与集成测试
   - Electron打包
   - 部署与分发

通过这种渐进式的迁移策略，我们可以确保在每个阶段都有可用的产品，同时逐步增强功能和用户体验。